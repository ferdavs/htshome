esp32:
  board: adafruit_feather_esp32_v2
  framework: 
    type: arduino
    sdkconfig_options:
      CONFIG_BT_ENABLED: y
      CONFIG_BT_CLASSIC_ENABLED: y
      CONFIG_BT_SPP_ENABLED: y
    
esphome:
  name: htshome
  libraries:
    - "h2zero/NimBLE-Arduino@2.3.7"
  on_boot:
    then:
      - output.turn_on: neopixel_power

logger:
  baud_rate: 115200
  
i2c:

external_components:
  - source: "./custom_components"
    components: ["ble_advertiser"]

bme68x_bsec2_i2c:
  # Default: 0x76 or 0x77
  address: 0x76
  temperature_offset: 0
  model: bme688
  # Default: static or mobile
  # iaq_mode: static # currently not working
  # Default: lp or ulp
  sample_rate: lp
  operating_age: 28d
  # Default: 6h
  state_save_interval: 1h

sensor:
  - platform: bme68x_bsec2
    temperature:
      name: "Env Temperature"
      id: "temperature"
      filters:
        - median
    humidity:
      name: "Env Humidity"
      id: "humidity"
      filters:
        - median
    pressure:
      name: "Env Pressure"
      id: "pressure"
      icon: "mdi:gauge"
      filters:
        - median
    co2_equivalent:
      id: co2
      name: "Env CO2 Equivalent"
      icon: "mdi:molecule-co2"
      filters:
        - median
    breath_voc_equivalent:
      id: breath_voc
      name: "Env bVOC Equivalent"
      icon: "mdi:molecule"
      filters:
        - median
  
    iaq_accuracy:
      id: iaq_accuracy
      name: "IAQ Status"
      icon: "mdi:check-circle"
      filters:
        - median

    iaq:
      id: iaq_env
      name: "IAQ"
      icon: "mdi:approximately-equal"
      filters:
        - median
        
    gas_resistance:
      id: gas_resistance
      name: "Env Gas Resistance"
      icon: "mdi:omega"
      accuracy_decimals: 1
      unit_of_measurement: "kOhm"
      filters:
        - median
        - lambda: return x / 1000.0;  # Convert Ohm to kOhm
  
  - platform: uptime
    id: uptime_sensor
    name: Uptime
    update_interval: 5s

  - platform: pmsa003i
    id: pm_sensor
    update_interval: 5s
    pm_1_0:
      name: "PM1.0"
      id: pm_1_0
    pm_2_5:
      name: "PM2.5"
      id: pm_2_5
    pm_10_0:
      name: "PM10.0"
      id: pm_10_0
    pmc_0_3:
      id: pmc_0_3
      name: "PMC >0.3µm"
    pmc_0_5:
      id: pmc_0_5
      name: "PMC >0.5µm"
    pmc_1_0:
      id: pmc_1_0
      name: "PMC >1µm"
    pmc_2_5:
      id: pmc_2_5
      name: "PMC >2.5µm"
    pmc_5_0:
      id: pmc_5_0
      name: "PMC >5µm"
    pmc_10_0:
      id: pmc_10_0
      name: "PMC >10µm"

  # - platform: absolute_humidity
  #   name: Absolute Humidity
  #   icon: "mdi:water"
  #   temperature: temperature
  #   humidity: humidity
  #   filters:
  #     - median

  - platform: adc
    id: battery_voltage
    name: "Battery voltage"
    pin: GPIO35
    accuracy_decimals: 2
    update_interval: 5s
    attenuation: auto
    filters:
      - multiply: 2.0  # The voltage divider requires us to multiply by 2
      - median

  # - platform: wifi_signal
  #   id: wifi_signal_rssi
  #   name: "WiFi Signal"
  #   entity_category: "diagnostic"
  #   update_interval: 5s
            

  - platform: template
    name: "IAQ only PM2.5"
    id: iaq_pm
    unit_of_measurement: "IAQ"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      // Get PM values
      float pm2_5 = id(pm_2_5).state;

      // Compute AQI based on PM2.5 (EPA AQI formula for PM2.5, simplified)
      float aqi_pm25;
      if (pm2_5 <= 12.0) {
        aqi_pm25 = (50.0 / 12.0) * pm2_5;  // Good
      } else if (pm2_5 <= 35.4) {
        aqi_pm25 = 50.0 + ((100.0 - 50.0) / (35.4 - 12.1)) * (pm2_5 - 12.1);  // Moderate
      } else if (pm2_5 <= 55.4) {
        aqi_pm25 = 100.0 + ((150.0 - 100.0) / (55.4 - 35.5)) * (pm2_5 - 35.5);  // Unhealthy for Sensitive Groups
      } else if (pm2_5 <= 150.4) {
        aqi_pm25 = 150.0 + ((200.0 - 150.0) / (150.4 - 55.5)) * (pm2_5 - 55.5);  // Unhealthy
      } else if (pm2_5 <= 250.4) {
        aqi_pm25 = 200.0 + ((300.0 - 200.0) / (250.4 - 150.5)) * (pm2_5 - 150.5);  // Very Unhealthy
      } else {
        aqi_pm25 = 300.0 + ((500.0 - 300.0) / (500.4 - 250.5)) * (pm2_5 - 250.5);  // Hazardous
      }

      return aqi_pm25;

  - platform: template
    name: "IAQ Averaged"
    id: iaq_averaged
    unit_of_measurement: "IAQ"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      // Get the base IAQ and PM-based IAQ values
      float base_iaq = id(iaq_env).state;
      float pm_iaq = id(iaq_pm).state;

      // Define weights for the average
      // float weight_base = 0.4;  // Base IAQ 
      // float weight_pm = 0.6;    // PM-based IAQ

      // Calculate weighted average IAQ
      //float averaged_iaq = (weight_base * base_iaq + weight_pm * pm_iaq) / (weight_base + weight_pm);

      // Ensure IAQ stays within the 0 to 500 range
      //if (averaged_iaq > 500) {
      //  averaged_iaq = 500;
      //} else if (averaged_iaq < 0) {
      //  averaged_iaq = 0;
      //}

      return max(base_iaq, pm_iaq);  // Use the maximum of the two values

ble_advertiser:
  update_interval: 1s
  min_interval: 128
  max_interval: 256
  device_name: "HTS-HOME"
  power_level: 9
  sensors:
    - id: uptime_sensor
      label: Uptime
      unit: s
      precision: 0
    - id: temperature
      label: "Temperature"
      unit: "°C"
      precision: 1
    - id: humidity
      label: "Humidity"
      unit: "%"
      precision: 1
    - id: pressure
      label: "Pressure"
      unit: "hPa"
      precision: 1
    - id: co2
      label: "CO₂"
      unit: "ppm"
      precision: 0
    - id: pm_1_0
      label: "PM1.0"
      unit: "µg/m³"
      precision: 1
    - id: pm_2_5
      label: "PM2.5"
      unit: "µg/m³"
      precision: 1
    - id: pm_10_0
      label: "PM10.0"
      unit: "µg/m³"
      precision: 1
    - id: iaq_averaged
      label: "IAQ"
      unit: ""
      precision: 0
    - id: breath_voc
      label: VOC
      unit: ppm
      precision: 1
    # - id: gas_resistance
    #   label: "Gas Resistance"
    #   unit: "kΩ" 
    #   precision: 1
    # - id: battery_voltage
    #   label: "Battery"
    #   unit: "V"
    #   precision: 2

output:
  - platform: gpio
    pin: GPIO2
    id: neopixel_power


light:
  - platform: neopixelbus
    variant: WS2812 
    type: GRB
    pin: GPIO0
    method: esp32_i2s
    num_leds: 1
    id: neo_pixel
    restore_mode: ALWAYS_ON
    default_transition_length: 0s

script:
  - id: test_led
    mode: single
    then:
      - lambda: |-
          float iaq = id(iaq_averaged).state;
          float r = 0.0, g = 0.0, b = 1.0;  // default to blue
          float brightness = 0.2;

          if (!isnan(iaq) && iaq >= 0) {
            // Clamp IAQ to 0-300
            iaq = fminf(fmaxf(iaq, 0.0), 300.0);

            // Map IAQ 0-300 to Hue 120 (green) to 340 (maroon)
            float hue = 120.0 - ((iaq / 300.0) * 200.0);
            hue = fmodf(hue + 360.0f, 360.0f);  // ensure hue is [0,360)

            // HSV to RGB math
            float sat = 1.0;
            float val = 1.0;
            float c = val * sat;
            float h_prime = hue / 60.0;
            float x = c * (1.0 - fabsf(fmodf(h_prime, 2.0) - 1.0));
            float m = val - c;

            // Precomputed RGB base cases for the 6 hue sectors
            float rgb_cases[6][3] = {
              {c, x, 0},
              {x, c, 0},
              {0, c, x},
              {0, x, c},
              {x, 0, c},
              {c, 0, x}
            };

            int sector = (int)h_prime % 6;
            r = rgb_cases[sector][0] + m;
            g = rgb_cases[sector][1] + m;
            b = rgb_cases[sector][2] + m;

            ESP_LOGD("neopixel", "IAQ %.1f → hue %.1f → R=%.2f G=%.2f B=%.2f", iaq, hue, r, g, b);
          } 

          // Ensure power is on
          id(neopixel_power).turn_on();

          auto call = id(neo_pixel).turn_on();
          call.set_red(r);
          call.set_green(g);
          call.set_blue(b);
          call.set_brightness(brightness);
          call.set_transition_length(0);
          call.perform();

interval:
  - interval: 1s
    then:
      - script.execute: test_led
